/**
 * @author generated by eTrice
 *
 * Dispatcher File of Node node with SubSystem subSystemRef
 * contains a generated message dispatcher (receiveMessage) for each MessageService (Thread)
 */

#include "messaging/etMessageReceiver.h"
#include "debugging/etLogger.h"
#include "debugging/etMSCLogger.h"


/**
 * generated execute function for all cyclic execute calls for the async or datadriven actor instances of thread "DefaultPhysicalThread"
 */
static void MsgDispatcher_DefaultPhysicalThread_poll(void){
	ET_MSC_LOGGER_SYNC_ENTRY("MsgDispatcher_DefaultPhysicalThread", "execute")
	ATimerService_execute((ATimerService*)&_LogSys_subSystemRef_timingService);
	ET_MSC_LOGGER_SYNC_EXIT
}

/**
 * generated dispatch function for all messages for the thread "DefaultPhysicalThread"
 */
static etBool MsgDispatcher_DefaultPhysicalThread_receiveMessage(const etMessage* msg){
	ET_MSC_LOGGER_SYNC_ENTRY("MsgDispatcher_DefaultPhysicalThread", "receiveMessage")
	switch(msg->address){

		case MESSAGESERVICE_ADDRESS:
			if (msg->evtID == etSystemProtocol_IN_poll) {
				MsgDispatcher_DefaultPhysicalThread_poll();
				logData();
			}
			else
			if (msg->evtID == etSystemProtocol_IN_terminate)
				return ET_FALSE;
			break;

		/* interface items of /LogSys/subSystemRef/topActor */

		/* interface items of /LogSys/subSystemRef/topActor/tempSensor */
		case 3+BASE_ADDRESS:
			ET_MSC_LOGGER_ASYNC_IN(
				((etPort*)&_LogSys_subSystemRef_topActor_tempSensor_const.sendTempLevel)->peerInstName,
				tempLvlInfo_getMessageString(msg->evtID),
				((etPort*)&_LogSys_subSystemRef_topActor_tempSensor_const.sendTempLevel)->myInstName
				)
			TempActor_receiveMessage((void*)&_LogSys_subSystemRef_topActor_tempSensor,(etPort*)&_LogSys_subSystemRef_topActor_tempSensor_const.sendTempLevel, msg);
			break;
		case 4+BASE_ADDRESS:
			switch (msg->evtID){
				case PTimer_OUT__timeout:
					PTimerConjPort__timeout_receiveHandler((etPort *)&_LogSys_subSystemRef_topActor_tempSensor_const.timer,msg,(void*)&_LogSys_subSystemRef_topActor_tempSensor,TempActor_receiveMessage);
					break;
				default: TempActor_receiveMessage((void*)&_LogSys_subSystemRef_topActor_tempSensor,(etPort*)&_LogSys_subSystemRef_topActor_tempSensor_const.timer, msg);
					break;
			}
			break;

		/* interface items of /LogSys/subSystemRef/topActor/fuelLvlSensor */
		case 6+BASE_ADDRESS:
			ET_MSC_LOGGER_ASYNC_IN(
				((etPort*)&_LogSys_subSystemRef_topActor_fuelLvlSensor_const.sendFluelLevel)->peerInstName,
				flLvlInfo_getMessageString(msg->evtID),
				((etPort*)&_LogSys_subSystemRef_topActor_fuelLvlSensor_const.sendFluelLevel)->myInstName
				)
			WaterLevelActor_receiveMessage((void*)&_LogSys_subSystemRef_topActor_fuelLvlSensor,(etPort*)&_LogSys_subSystemRef_topActor_fuelLvlSensor_const.sendFluelLevel, msg);
			break;
		case 7+BASE_ADDRESS:
			switch (msg->evtID){
				case PTimer_OUT__timeout:
					PTimerConjPort__timeout_receiveHandler((etPort *)&_LogSys_subSystemRef_topActor_fuelLvlSensor_const.timer,msg,(void*)&_LogSys_subSystemRef_topActor_fuelLvlSensor,WaterLevelActor_receiveMessage);
					break;
				default: WaterLevelActor_receiveMessage((void*)&_LogSys_subSystemRef_topActor_fuelLvlSensor,(etPort*)&_LogSys_subSystemRef_topActor_fuelLvlSensor_const.timer, msg);
					break;
			}
			break;

		/* interface items of /LogSys/subSystemRef/topActor/fuelLevelControler */
		case 9+BASE_ADDRESS:
			ET_MSC_LOGGER_ASYNC_IN(
				((etPort*)&_LogSys_subSystemRef_topActor_fuelLevelControler_const.receiveWLLevel)->peerInstName,
				flLvlInfo_getMessageString(msg->evtID),
				((etPort*)&_LogSys_subSystemRef_topActor_fuelLevelControler_const.receiveWLLevel)->myInstName
				)
			NotifyOperatorWLCmd_receiveMessage((void*)&_LogSys_subSystemRef_topActor_fuelLevelControler,(etPort*)&_LogSys_subSystemRef_topActor_fuelLevelControler_const.receiveWLLevel, msg);
			break;
		case 10+BASE_ADDRESS:
			ET_MSC_LOGGER_ASYNC_IN(
				((etPort*)&_LogSys_subSystemRef_topActor_fuelLevelControler_const.sendCritical)->peerInstName,
				sendInfoCriticalFL_getMessageString(msg->evtID),
				((etPort*)&_LogSys_subSystemRef_topActor_fuelLevelControler_const.sendCritical)->myInstName
				)
			NotifyOperatorWLCmd_receiveMessage((void*)&_LogSys_subSystemRef_topActor_fuelLevelControler,(etPort*)&_LogSys_subSystemRef_topActor_fuelLevelControler_const.sendCritical, msg);
			break;

		/* interface items of /LogSys/subSystemRef/topActor/missilePositionReceiver */
		case 12+BASE_ADDRESS:
			ET_MSC_LOGGER_ASYNC_IN(
				((etPort*)&_LogSys_subSystemRef_topActor_missilePositionReceiver_const.sendDistance)->peerInstName,
				uwbInfo_getMessageString(msg->evtID),
				((etPort*)&_LogSys_subSystemRef_topActor_missilePositionReceiver_const.sendDistance)->myInstName
				)
			UwbSensorMissileData_receiveMessage((void*)&_LogSys_subSystemRef_topActor_missilePositionReceiver,(etPort*)&_LogSys_subSystemRef_topActor_missilePositionReceiver_const.sendDistance, msg);
			break;
		case 13+BASE_ADDRESS:
			switch (msg->evtID){
				case PTimer_OUT__timeout:
					PTimerConjPort__timeout_receiveHandler((etPort *)&_LogSys_subSystemRef_topActor_missilePositionReceiver_const.timer,msg,(void*)&_LogSys_subSystemRef_topActor_missilePositionReceiver,UwbSensorMissileData_receiveMessage);
					break;
				default: UwbSensorMissileData_receiveMessage((void*)&_LogSys_subSystemRef_topActor_missilePositionReceiver,(etPort*)&_LogSys_subSystemRef_topActor_missilePositionReceiver_const.timer, msg);
					break;
			}
			break;

		/* interface items of /LogSys/subSystemRef/topActor/tempLevelController */
		case 15+BASE_ADDRESS:
			ET_MSC_LOGGER_ASYNC_IN(
				((etPort*)&_LogSys_subSystemRef_topActor_tempLevelController_const.receiveTempLevel)->peerInstName,
				tempLvlInfo_getMessageString(msg->evtID),
				((etPort*)&_LogSys_subSystemRef_topActor_tempLevelController_const.receiveTempLevel)->myInstName
				)
			NotifyOperatorTempCmd_receiveMessage((void*)&_LogSys_subSystemRef_topActor_tempLevelController,(etPort*)&_LogSys_subSystemRef_topActor_tempLevelController_const.receiveTempLevel, msg);
			break;

		/* interface items of /LogSys/subSystemRef/topActor/fireMissile */
		case 17+BASE_ADDRESS:
			ET_MSC_LOGGER_ASYNC_IN(
				((etPort*)&_LogSys_subSystemRef_topActor_fireMissile_const.receiveFireCmd)->peerInstName,
				fire_getMessageString(msg->evtID),
				((etPort*)&_LogSys_subSystemRef_topActor_fireMissile_const.receiveFireCmd)->myInstName
				)
			FireMissile_receiveMessage((void*)&_LogSys_subSystemRef_topActor_fireMissile,(etPort*)&_LogSys_subSystemRef_topActor_fireMissile_const.receiveFireCmd, msg);
			break;
		case 18+BASE_ADDRESS:
			ET_MSC_LOGGER_ASYNC_IN(
				((etPort*)&_LogSys_subSystemRef_topActor_fireMissile_const.receiveCrititcalInfo)->peerInstName,
				sendInfoCriticalFL_getMessageString(msg->evtID),
				((etPort*)&_LogSys_subSystemRef_topActor_fireMissile_const.receiveCrititcalInfo)->myInstName
				)
			FireMissile_receiveMessage((void*)&_LogSys_subSystemRef_topActor_fireMissile,(etPort*)&_LogSys_subSystemRef_topActor_fireMissile_const.receiveCrititcalInfo, msg);
			break;
		case 19+BASE_ADDRESS:
			switch (msg->evtID){
				case PTimer_OUT__timeout:
					PTimerConjPort__timeout_receiveHandler((etPort *)&_LogSys_subSystemRef_topActor_fireMissile_const.timer,msg,(void*)&_LogSys_subSystemRef_topActor_fireMissile,FireMissile_receiveMessage);
					break;
				default: FireMissile_receiveMessage((void*)&_LogSys_subSystemRef_topActor_fireMissile,(etPort*)&_LogSys_subSystemRef_topActor_fireMissile_const.timer, msg);
					break;
			}
			break;

		/* interface items of /LogSys/subSystemRef/topActor/calculateIfLaunching */
		case 21+BASE_ADDRESS:
			ET_MSC_LOGGER_ASYNC_IN(
				((etPort*)&_LogSys_subSystemRef_topActor_calculateIfLaunching_const.sendFireCmd)->peerInstName,
				fire_getMessageString(msg->evtID),
				((etPort*)&_LogSys_subSystemRef_topActor_calculateIfLaunching_const.sendFireCmd)->myInstName
				)
			CheckIfLaunchingMissileData_receiveMessage((void*)&_LogSys_subSystemRef_topActor_calculateIfLaunching,(etPort*)&_LogSys_subSystemRef_topActor_calculateIfLaunching_const.sendFireCmd, msg);
			break;
		case 22+BASE_ADDRESS:
			ET_MSC_LOGGER_ASYNC_IN(
				((etPort*)&_LogSys_subSystemRef_topActor_calculateIfLaunching_const.receiveDistance)->peerInstName,
				uwbInfo_getMessageString(msg->evtID),
				((etPort*)&_LogSys_subSystemRef_topActor_calculateIfLaunching_const.receiveDistance)->myInstName
				)
			CheckIfLaunchingMissileData_receiveMessage((void*)&_LogSys_subSystemRef_topActor_calculateIfLaunching,(etPort*)&_LogSys_subSystemRef_topActor_calculateIfLaunching_const.receiveDistance, msg);
			break;
		case 23+BASE_ADDRESS:
			switch (msg->evtID){
				case PTimer_OUT__timeout:
					PTimerConjPort__timeout_receiveHandler((etPort *)&_LogSys_subSystemRef_topActor_calculateIfLaunching_const.timer,msg,(void*)&_LogSys_subSystemRef_topActor_calculateIfLaunching,CheckIfLaunchingMissileData_receiveMessage);
					break;
				default: CheckIfLaunchingMissileData_receiveMessage((void*)&_LogSys_subSystemRef_topActor_calculateIfLaunching,(etPort*)&_LogSys_subSystemRef_topActor_calculateIfLaunching_const.timer, msg);
					break;
			}
			break;

		/* interface items of /LogSys/subSystemRef/timingService */
		case 25+BASE_ADDRESS:
			ET_MSC_LOGGER_ASYNC_IN(
				_LogSys_subSystemRef_timingService_const.timer.ports[0].port.peerInstName,
				PTimer_getMessageString(msg->evtID),
				_LogSys_subSystemRef_timingService_const.timer.ports[0].port.myInstName
				)
			ATimerService_receiveMessage((void*)&_LogSys_subSystemRef_timingService,&_LogSys_subSystemRef_timingService_const.timer.ports[0].port, msg);
		break;
		case 26+BASE_ADDRESS:
			ET_MSC_LOGGER_ASYNC_IN(
				_LogSys_subSystemRef_timingService_const.timer.ports[1].port.peerInstName,
				PTimer_getMessageString(msg->evtID),
				_LogSys_subSystemRef_timingService_const.timer.ports[1].port.myInstName
				)
			ATimerService_receiveMessage((void*)&_LogSys_subSystemRef_timingService,&_LogSys_subSystemRef_timingService_const.timer.ports[1].port, msg);
		break;
		case 27+BASE_ADDRESS:
			ET_MSC_LOGGER_ASYNC_IN(
				_LogSys_subSystemRef_timingService_const.timer.ports[2].port.peerInstName,
				PTimer_getMessageString(msg->evtID),
				_LogSys_subSystemRef_timingService_const.timer.ports[2].port.myInstName
				)
			ATimerService_receiveMessage((void*)&_LogSys_subSystemRef_timingService,&_LogSys_subSystemRef_timingService_const.timer.ports[2].port, msg);
		break;
		case 28+BASE_ADDRESS:
			ET_MSC_LOGGER_ASYNC_IN(
				_LogSys_subSystemRef_timingService_const.timer.ports[3].port.peerInstName,
				PTimer_getMessageString(msg->evtID),
				_LogSys_subSystemRef_timingService_const.timer.ports[3].port.myInstName
				)
			ATimerService_receiveMessage((void*)&_LogSys_subSystemRef_timingService,&_LogSys_subSystemRef_timingService_const.timer.ports[3].port, msg);
		break;
		case 29+BASE_ADDRESS:
			ET_MSC_LOGGER_ASYNC_IN(
				_LogSys_subSystemRef_timingService_const.timer.ports[4].port.peerInstName,
				PTimer_getMessageString(msg->evtID),
				_LogSys_subSystemRef_timingService_const.timer.ports[4].port.myInstName
				)
			ATimerService_receiveMessage((void*)&_LogSys_subSystemRef_timingService,&_LogSys_subSystemRef_timingService_const.timer.ports[4].port, msg);
		break;

		default:
			etLogger_logErrorF("MessageService_DefaultPhysicalThread_receiveMessage: address %d does not exist ", msg->address);
			break;
	}
	ET_MSC_LOGGER_SYNC_EXIT
	return ET_TRUE;
}
