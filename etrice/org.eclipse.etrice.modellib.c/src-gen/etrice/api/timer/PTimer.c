/**
 * @author generated by eTrice
 *
 * Source File of ProtocolClass PTimer
 * 
 */

#include "PTimer.h"
#include "debugging/etMSCLogger.h"
#include "PTimer_Utils.h"

/*--------------------- begin user code ---------------------*/
#define ET_TIMER_IDLE		0x00
#define ET_TIMER_ONCE		0x01
#define ET_TIMER_PERIODIC	0x02

/*--------------------- end user code ---------------------*/

/*--------------------- port methods */

void PTimerPort_timeout(const PTimerPort* self) {
	ET_MSC_LOGGER_SYNC_ENTRY("PTimerPort", "timeout")
		etPort_sendMessage(self, PTimer_OUT_timeout, 0, NULL);
		ET_MSC_LOGGER_ASYNC_OUT(self->myInstName, "timeout", self->peerInstName)
	ET_MSC_LOGGER_SYNC_EXIT
}

void PTimerReplPort_timeout_broadcast(const PTimerReplPort* self) {
	int i;
	ET_MSC_LOGGER_SYNC_ENTRY("PTimerReplPort", "timeout")
	for (i=0; i<((etReplPort*)self)->size; ++i) {
		etPort_sendMessage((&((etReplPort*)self)->ports[i].port), PTimer_OUT_timeout, 0, NULL);
		ET_MSC_LOGGER_ASYNC_OUT(((etReplPort*)self)->ports[i].port.myInstName, "timeout", ((etReplPort*)self)->ports[i].port.peerInstName)
	}
	ET_MSC_LOGGER_SYNC_EXIT
}

void PTimerReplPort_timeout(const PTimerReplPort* self, int idx__et) {
	ET_MSC_LOGGER_SYNC_ENTRY("PTimerReplPort", "timeout")
	if (0<=idx__et && idx__et<((etReplPort*)self)->size) {
		etPort_sendMessage((&((etReplPort*)self)->ports[idx__et].port), PTimer_OUT_timeout, 0, NULL);
		ET_MSC_LOGGER_ASYNC_OUT(((etReplPort*)self)->ports[idx__et].port.myInstName, "timeout", ((etReplPort*)self)->ports[idx__et].port.peerInstName)
	}
	ET_MSC_LOGGER_SYNC_EXIT
}


void PTimerPort__timeout(const PTimerPort* self, uint16 data__et) {
	ET_MSC_LOGGER_SYNC_ENTRY("PTimerPort", "_timeout")
		etPort_sendMessage(self, PTimer_OUT__timeout, sizeof(uint16), &data__et);
		ET_MSC_LOGGER_ASYNC_OUT(self->myInstName, "_timeout", self->peerInstName)
	ET_MSC_LOGGER_SYNC_EXIT
}

void PTimerReplPort__timeout_broadcast(const PTimerReplPort* self, uint16 data__et) {
	int i;
	ET_MSC_LOGGER_SYNC_ENTRY("PTimerReplPort", "_timeout")
	for (i=0; i<((etReplPort*)self)->size; ++i) {
		etPort_sendMessage((&((etReplPort*)self)->ports[i].port), PTimer_OUT__timeout, sizeof(uint16), &data__et);
		ET_MSC_LOGGER_ASYNC_OUT(((etReplPort*)self)->ports[i].port.myInstName, "_timeout", ((etReplPort*)self)->ports[i].port.peerInstName)
	}
	ET_MSC_LOGGER_SYNC_EXIT
}

void PTimerReplPort__timeout(const PTimerReplPort* self, int idx__et, uint16 data__et) {
	ET_MSC_LOGGER_SYNC_ENTRY("PTimerReplPort", "_timeout")
	if (0<=idx__et && idx__et<((etReplPort*)self)->size) {
		etPort_sendMessage((&((etReplPort*)self)->ports[idx__et].port), PTimer_OUT__timeout, sizeof(uint16), &data__et);
		ET_MSC_LOGGER_ASYNC_OUT(((etReplPort*)self)->ports[idx__et].port.myInstName, "_timeout", ((etReplPort*)self)->ports[idx__et].port.peerInstName)
	}
	ET_MSC_LOGGER_SYNC_EXIT
}

/* begin PTimerPort specific (including base classes) */

/*--------------------- operations ---------------------*/
/* end PTimerPort specific (including base classes) */

etInt32 PTimerReplPort_getReplication(const PTimerReplPort* self) {
	return ((etReplPort*)self)->size;
}



void PTimerConjPort_startTimer(const PTimerConjPort* self, uint32 data__et) {
	if (status == ET_TIMER_IDLE) {
		status = ET_TIMER_PERIODIC;
		DStartTimer _data = { .timeMs = data__et, .timeId = ++currentTimeId };
		PTimerConjPort__startTimer(self, &_data);
	}
}

void PTimerConjReplPort_startTimer_broadcast(const PTimerConjReplPort* self, uint32 data__et) {
	int i;
	for (i=0; i<((etReplPort*)self)->size; ++i) {
		PTimerConjPort_startTimer(&((etReplPort*)self)->ports[i].port, data__et);
	}
}

void PTimerConjReplPort_startTimer(const PTimerConjReplPort* self, int idx__et, uint32 data__et) {
	PTimerConjPort_startTimer(&((etReplPort*)self)->ports[idx__et].port, data__et);
}


void PTimerConjPort_startTimeout(const PTimerConjPort* self, uint32 data__et) {
	if (status == ET_TIMER_IDLE) {
		status = ET_TIMER_ONCE;
		DStartTimer _data = { .timeMs = data__et, .timeId = ++currentTimeId };
		PTimerConjPort__startTimeout(self, &_data);
	}
}

void PTimerConjReplPort_startTimeout_broadcast(const PTimerConjReplPort* self, uint32 data__et) {
	int i;
	for (i=0; i<((etReplPort*)self)->size; ++i) {
		PTimerConjPort_startTimeout(&((etReplPort*)self)->ports[i].port, data__et);
	}
}

void PTimerConjReplPort_startTimeout(const PTimerConjReplPort* self, int idx__et, uint32 data__et) {
	PTimerConjPort_startTimeout(&((etReplPort*)self)->ports[idx__et].port, data__et);
}


void PTimerConjPort_kill(const PTimerConjPort* self) {
	if (status != ET_TIMER_IDLE) {
		status = ET_TIMER_IDLE;
		etPort_sendMessage(self, PTimer_IN_kill, 0, NULL);
		ET_MSC_LOGGER_ASYNC_OUT(self->myInstName, "kill", self->peerInstName);
	}
}

void PTimerConjReplPort_kill_broadcast(const PTimerConjReplPort* self) {
	int i;
	for (i=0; i<((etReplPort*)self)->size; ++i) {
		PTimerConjPort_kill(&((etReplPort*)self)->ports[i].port);
	}
}

void PTimerConjReplPort_kill(const PTimerConjReplPort* self, int idx__et) {
	PTimerConjPort_kill(&((etReplPort*)self)->ports[idx__et].port);
}


void PTimerConjPort__startTimer(const PTimerConjPort* self, DStartTimer* data__et) {
	ET_MSC_LOGGER_SYNC_ENTRY("PTimerConjPort", "_startTimer")
		etPort_sendMessage(self, PTimer_IN__startTimer, sizeof(DStartTimer), data__et);
		ET_MSC_LOGGER_ASYNC_OUT(self->myInstName, "_startTimer", self->peerInstName)
	ET_MSC_LOGGER_SYNC_EXIT
}

void PTimerConjReplPort__startTimer_broadcast(const PTimerConjReplPort* self, DStartTimer* data__et) {
	int i;
	ET_MSC_LOGGER_SYNC_ENTRY("PTimerConjReplPort", "_startTimer")
	for (i=0; i<((etReplPort*)self)->size; ++i) {
		etPort_sendMessage((&((etReplPort*)self)->ports[i].port), PTimer_IN__startTimer, sizeof(DStartTimer), data__et);
		ET_MSC_LOGGER_ASYNC_OUT(((etReplPort*)self)->ports[i].port.myInstName, "_startTimer", ((etReplPort*)self)->ports[i].port.peerInstName)
	}
	ET_MSC_LOGGER_SYNC_EXIT
}

void PTimerConjReplPort__startTimer(const PTimerConjReplPort* self, int idx__et, DStartTimer* data__et) {
	ET_MSC_LOGGER_SYNC_ENTRY("PTimerConjReplPort", "_startTimer")
	if (0<=idx__et && idx__et<((etReplPort*)self)->size) {
		etPort_sendMessage((&((etReplPort*)self)->ports[idx__et].port), PTimer_IN__startTimer, sizeof(DStartTimer), data__et);
		ET_MSC_LOGGER_ASYNC_OUT(((etReplPort*)self)->ports[idx__et].port.myInstName, "_startTimer", ((etReplPort*)self)->ports[idx__et].port.peerInstName)
	}
	ET_MSC_LOGGER_SYNC_EXIT
}


void PTimerConjPort__startTimeout(const PTimerConjPort* self, DStartTimer* data__et) {
	ET_MSC_LOGGER_SYNC_ENTRY("PTimerConjPort", "_startTimeout")
		etPort_sendMessage(self, PTimer_IN__startTimeout, sizeof(DStartTimer), data__et);
		ET_MSC_LOGGER_ASYNC_OUT(self->myInstName, "_startTimeout", self->peerInstName)
	ET_MSC_LOGGER_SYNC_EXIT
}

void PTimerConjReplPort__startTimeout_broadcast(const PTimerConjReplPort* self, DStartTimer* data__et) {
	int i;
	ET_MSC_LOGGER_SYNC_ENTRY("PTimerConjReplPort", "_startTimeout")
	for (i=0; i<((etReplPort*)self)->size; ++i) {
		etPort_sendMessage((&((etReplPort*)self)->ports[i].port), PTimer_IN__startTimeout, sizeof(DStartTimer), data__et);
		ET_MSC_LOGGER_ASYNC_OUT(((etReplPort*)self)->ports[i].port.myInstName, "_startTimeout", ((etReplPort*)self)->ports[i].port.peerInstName)
	}
	ET_MSC_LOGGER_SYNC_EXIT
}

void PTimerConjReplPort__startTimeout(const PTimerConjReplPort* self, int idx__et, DStartTimer* data__et) {
	ET_MSC_LOGGER_SYNC_ENTRY("PTimerConjReplPort", "_startTimeout")
	if (0<=idx__et && idx__et<((etReplPort*)self)->size) {
		etPort_sendMessage((&((etReplPort*)self)->ports[idx__et].port), PTimer_IN__startTimeout, sizeof(DStartTimer), data__et);
		ET_MSC_LOGGER_ASYNC_OUT(((etReplPort*)self)->ports[idx__et].port.myInstName, "_startTimeout", ((etReplPort*)self)->ports[idx__et].port.peerInstName)
	}
	ET_MSC_LOGGER_SYNC_EXIT
}

/* begin PTimerConjPort specific (including base classes) */

/*--------------------- operations ---------------------*/
/* end PTimerConjPort specific (including base classes) */

etInt32 PTimerConjReplPort_getReplication(const PTimerConjReplPort* self) {
	return ((etReplPort*)self)->size;
}

/* receiver handlers */
void PTimerConjPort__timeout_receiveHandler(PTimerConjPort* self, const etMessage* msg, void * actor, etActorReceiveMessage receiveMessageFunc){
	ET_MSC_LOGGER_ASYNC_IN(self->peerInstName, "_timeout", self->myInstName);
	uint16 receivedTimeId = *((uint16*) etPort_getMessageDataPtr(msg));
	if (status != ET_TIMER_IDLE && receivedTimeId == currentTimeId){
		status = (status == ET_TIMER_ONCE) ? ET_TIMER_IDLE : ET_TIMER_PERIODIC;
		/* msg to fsm */
		etMessage _data = (etMessage) { .address = msg->address, .evtID = PTimer_OUT_timeout };
		(*receiveMessageFunc)(actor, self, &_data);
	} else {
		// add note for drop - omitting ASYNC_IN would cause wrong message receive order
		ET_MSC_LOGGER_NOTE(self->myInstName, "obsolete timeout dropped");
	}
	/* hand over the message to the actor:      */
	/* (*receiveMessageFunc)(actor, self, msg); */
}


/*--------------------- debug helpers */
#ifdef ET_ASYNC_MSC_LOGGER_ACTIVATE
	
	/* message names as strings for debugging (generate MSC) */
	static const char* const PTimer_messageStrings[] = {"MIN", "timeout","_timeout","startTimer", "startTimeout", "kill", "_startTimer", "_startTimeout", "MAX"};
	
	const char* PTimer_getMessageString(int msg_id) {
		if (msg_id<PTimer_MSG_MIN || msg_id>PTimer_MSG_MAX+1){
			/* id out of range */
			return "Message ID out of range";
		}
		else{
			return PTimer_messageStrings[msg_id];
		}
	}
#endif
